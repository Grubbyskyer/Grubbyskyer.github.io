<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Xing&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="爱足球，爱阅读，爱跑步。">
<meta property="og:type" content="website">
<meta property="og:title" content="Xing's Blog">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Xing's Blog">
<meta property="og:description" content="爱足球，爱阅读，爱跑步。">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Xing's Blog">
<meta name="twitter:description" content="爱足球，爱阅读，爱跑步。">
  
    <link rel="alternative" href="/atom.xml" title="Xing&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/img/author.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">TIAN Xing</a></h1>
		</hgroup>

		
		<p class="header-subtitle">人生的乐趣就在于永不休止地折腾、折腾、折腾...</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
							<li><a href="/instagram">相册</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/Grubbyskyer" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/234583516" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="http://www.zhihu.com/people/tian-xing-60-64" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/JSP/" style="font-size: 10px;">JSP</a><a href="/tags/Machine-Learning/" style="font-size: 20px;">Machine Learning</a><a href="/tags/Markdown/" style="font-size: 10px;">Markdown</a><a href="/tags/bitset/" style="font-size: 10px;">bitset</a><a href="/tags/hexo/" style="font-size: 15px;">hexo</a><a href="/tags/mysql/" style="font-size: 10px;">mysql</a><a href="/tags/python3/" style="font-size: 10px;">python3</a><a href="/tags/test/" style="font-size: 10px;">test</a><a href="/tags/爬虫/" style="font-size: 10px;">爬虫</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">中南大学10级，现在本校读研。研究机器学习和自然语言处理相关算法。直男癌O^·^O死♂宅O^·^O极客范</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">TIAN Xing</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="/img/author.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">TIAN Xing</h1>
			</hgroup>
			
			<p class="header-subtitle">人生的乐趣就在于永不休止地折腾、折腾、折腾...</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/instagram">相册</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/Grubbyskyer" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/234583516" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="http://www.zhihu.com/people/tian-xing-60-64" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-chapter12" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/03/10/chapter12/" class="article-date">
  	<time datetime="2015-03-10T13:06:53.000Z" itemprop="datePublished">Mar 10</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/10/chapter12/">chapter12-随机数，取样</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>Q1：从0~n-1这n个数中随机选出不重复的m个数并按序输出。</p>
</blockquote>
<p>首先我们应该知道概率事件的计算机表示：<br>如果一个事件A发生的概率为$\frac{m}{n}$，那么用编程语言表示就是：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (bigrand() % n &lt; m)</span><br><span class="line">	<span class="keyword">do</span> A;</span><br></pre></td></tr></table></figure></p>
<p>那么现在考虑这个问题，选择0的时候，我们以$\frac{m}{n}$的概率选择0，这是毫无疑问的；<br>选择1的时候，如果前面选了0，那么我们要以$\frac{m-1}{n-1}$的概率选择1，如果没有选择0，那么我们以$\frac{m}{n-1}$的概率选择1。<br>也就是说，还需要选的元素个数我们记为select，从remaining个元素进行选择，那么选择的概率为$\frac{select}{remaining}$<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i, n, m;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	<span class="keyword">if</span> (bigrand() % (n - i) &lt; m) &#123;<span class="comment">//n-i是当前剩余总元素数，m为当前还需要选的元素个数</span></span><br><span class="line">		print i;</span><br><span class="line">		m--;<span class="comment">//如果选择了当前元素，则remaining--</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为按照i=[0,n-1]这样的顺序遍历了数组，所以最终输出的肯定是有序的，复杂度为$O(n)$，而且每次都是以$\frac{select}{remaining}$的概率选择当前元素，所以每个元素被选中的概率相等。<br>那么现在还剩下最后一个问题：该算法会准确的输出m个元素吗？<br>答案是肯定的。我们可以这样分析：如果已经选择了m个元素，那么m=0，if括号中的条件恒为假，剩下的元素肯定不会被选择，所以肯定不会多选；如果当n-i == m的时候，还没有选满，那么if中的条件恒为真，剩下的所有元素都会被选择，所以也不会少选。举个例子，n=400，m=20，假设前面380个数都没有被选择，那么到了倒数第20个数，n-i = 20，m=20，剩下的20个数都会被选择。</p>
<p>另一种方法是，将n个数随即打乱，然后取前m个数，再排序输出<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	swap(i, randint(i, n - <span class="number">1</span>));</span><br><span class="line">sort(x, x + m);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">	print x[i]</span><br></pre></td></tr></table></figure></p>
<p>这样的复杂度为$O(n + mlogm)$，注意其中的交换函数</p>
<p>还有一种解决方案是用set，每次随机从0~n-1中选一个数放入set，直到set的size达到m。由于set每次插入的复杂度为$O(logm)$，所以总复杂度为$O(mlogm)$<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="keyword">while</span> (s.size() &lt; m)</span><br><span class="line">	s.insert(bigrand() % n);</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line"><span class="keyword">for</span> (it = s.begin(); it != s.end(); it++)</span><br><span class="line">	print *it</span><br></pre></td></tr></table></figure></p>
<p>但是这样有一点问题，就是当m和n比较接近的时候，越到后面重复的概率越高，会产生很多次浪费，一个改进的算法是：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line"><span class="keyword">int</span> j, t;</span><br><span class="line"><span class="keyword">for</span> (j = n- m; j &lt; n; j++) &#123;</span><br><span class="line">	t = bigrand() % (j + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (s.find(t) == s.end())</span><br><span class="line">		s.insert(t);<span class="comment">// t not in s</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		s.insert(j);<span class="comment">// t in s</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (it = s.begin(); it != s.end(); it++)</span><br><span class="line">	print *it</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>Q2：rand7() 到 rand5()、rand10()</p>
</blockquote>
<p>rand7()能随机返回1-7这7个整数中的一个，根据rand7()编写对应的rand5()和rand10()。<br>rand5()比较简单<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rand5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> res;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		res = rand7();</span><br><span class="line">	&#125; <span class="keyword">while</span> (res &gt;= <span class="number">6</span>);<span class="comment">//取出来6或者7就重取，1-5的概率是相等的</span></span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>rand10()稍微复杂一点：rand5()可以等概率返回1-5，那么rand5() + 5可以等概率返回6-10，把它们视为两个整体，现在只需要等概率返回这两个整体即可。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rand5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> res, t;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		res = rand7();</span><br><span class="line">	&#125; <span class="keyword">while</span> (res &gt;= <span class="number">6</span>);<span class="comment">//取出来6或者7就重取，1-5的概率是相等的</span></span><br><span class="line">	<span class="comment">//做一个1/2的概率生成器，最简单的利用奇偶性</span></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		t = rand7();</span><br><span class="line">	&#125; <span class="keyword">while</span> (res == <span class="number">7</span>);<span class="comment">//t为1-6，奇偶数相同各3个</span></span><br><span class="line">	res += <span class="number">5</span> * (t &amp; <span class="number">1</span>);<span class="comment">//t为0或1，即res有1/2的概率+5</span></span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>Q3：赠券收集者问题</p>
</blockquote>
<p>一套卡片总共有n张，分别是n种类型，这里假定每种类型卡片数量相等（被取到的概率一致），问收集齐整套卡片需要多少张卡片？</p>
<p>首先，买第一种卡片，这张肯定是原来没有的，概率为1；（这里第一种不是指0~n-1中的第0种，而是你收集的卡片的第一种，下同）<br>买第二种卡片时候，不能跟第一次重复，概率为$\frac{n-1}{n}$<br>买第三种，不能跟前两次重复，概率为$\frac{n-2}{n}$<br>…<br>买第n种，不能跟前面n-1种重复，概率为$\frac{1}{n}$<br>亦即$p_i = \frac{n + 1 - i}{n}$，而期望$E_i = \frac{1}{p_i} = \frac{n}{n + 1 - i}$<br>则$$sum = \sum_{i = 1}^n E_i = n (1 + \frac{1}{2} + \frac{1}{3} + \cdots +\frac{1}{n})$$<br>后面那一堆是调和级数，是发散的，和大约为<br>$ln(n + 1) + r \ (r \approx 0.5772156649)$<br>所以总和$sum \approx nlnn$</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/编程珠玑/">编程珠玑</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-chapter11" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/03/09/chapter11/" class="article-date">
  	<time datetime="2015-03-09T13:06:53.000Z" itemprop="datePublished">Mar 9</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/09/chapter11/">chapter11-插入排序、快排</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="插入排序">插入排序</h1><p>思路：给定一个数组x[0,n)，我们先把x[0…0]视为有序序列，插入x[1]，然后把x[0…1]视为有序序列，插入x[2]，…，最后把x[0…n-2]视为有序序列，插入x[n-1]。</p>
<p>复杂度：共需从x[1]到x[n-1] (n-1)趟插入，每次插入需要移动的距离为O(n)，所以最终复杂度为$O(n^2)$ 空间上只需要O(1)的交换元素空间，是原地排序</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, t;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++)<span class="comment">//将x[1]到x[n-1]依次插入</span></span><br><span class="line">        <span class="keyword">for</span> (j = i; j &gt; <span class="number">0</span> &amp;&amp; x[j] &lt; x[j - <span class="number">1</span>]; j--) &#123;</span><br><span class="line">	        <span class="comment">//如果该元素比它前面的小，就交换，直到它找到自己在前面序列的位置</span></span><br><span class="line">            t = x[j]; x[j] = x[j - <span class="number">1</span>]; x[j - <span class="number">1</span>] = t;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出插入排序的主要时间都耗费在了内层循环元素的移动上，如果原本数组就是有序的，那么O(n)时间就完成了。因此在元素<strong>基本有序</strong>的情况下，插入排序的效率是比较高的。</p>
<h1 id="快排">快排</h1><p>思路：快排的思想是对于一个数组x[l,r]，从中随机选取一个元素x[k]，然后把x中小于x[k]的元素都移到左边，大于等于x[k]的元素都移到右边，最终x[k]被移到了m位置，这样x[l,m-1]都小于x[m]，x[m+1,r]都大于等于x[m]。<br>接下来对于x[l,m-1]和x[m+1,r]再递归去排序，直到l&gt;=u证明数组中只有一个元素或没有元素则返回。</p>
<p>复杂度：每次选完枢轴元素之后移动的次数为O(n)，之后分治，最坏情况下一端为空，另一端为n-1，这样最坏也是O(n)，所以最坏情况下复杂度为$O(n^2)$ 平均情况下为$O(nlogn)$ 空间上，程序本身没有申请新的空间，但是运行时平均需要$O(logn)$的栈空间，最坏需要$O(n)$的栈空间<br>$$<br>T(n) = 2T(\frac{n}{2}) + O(n) \<br>n^{log_b^a} = n^{log_2^2} = n = f(n) = O(n) \<br>T(n) = O(n^{log_b^a}logn) = O(nlogn)<br>$$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qsort</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>; <span class="comment">//递归出口</span></span><br><span class="line">    <span class="keyword">int</span> i, m, t;</span><br><span class="line">    m = l;<span class="comment">//选取最左边的作为枢轴</span></span><br><span class="line">    <span class="keyword">for</span> (i = l + <span class="number">1</span>; i &lt;= r; i++)<span class="comment">//依次将后面的值与枢轴进行比较</span></span><br><span class="line">        <span class="keyword">if</span> (x[i] &lt; x[l]) &#123;<span class="comment">//如果比枢轴小 swap(++m, i); m存的是小于x[l]的元素的个数</span></span><br><span class="line">            t = x[++m]; x[m] = x[i]; x[i] = t;</span><br><span class="line">        &#125;</span><br><span class="line">    t = x[m]; x[m] = x[l]; x[l] = t;<span class="comment">//最终swap(l,m);</span></span><br><span class="line">    qsort(x, l, m - <span class="number">1</span>);</span><br><span class="line">    qsort(x, m + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每次都把x[m]“删除”了，所以肯定会终止。</p>
<p>几点改进：</p>
<ul>
<li>从单向搜索改为双向搜索</li>
<li>每次随机选取元素作为枢轴而不是最左边的</li>
<li>对于小数组使用插入排序直接返回</li>
</ul>
<p>使用双向搜索，原来只是每次从前面找比枢轴小的，现在从前面找到第一个大于等于枢轴的，从后面找到第一个小于等于枢轴的，交换它们的值，直到这两个指针相遇<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;cstdio&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qsort</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> i, j, t;</span><br><span class="line">    i = l; j = r + <span class="number">1</span>; <span class="comment">//注意i、j的初始化</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;<span class="comment">//为什么写成do while形式？因为交换完x[i]、x[j]的值，都要让i、j往前走一步，否则数组中有两个跟枢轴相等的，就死循环了</span></span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">while</span> (i &lt;= r &amp;&amp; x[i] &lt; x[l]);<span class="comment">//找到第一个大于等于x[l]</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125; <span class="keyword">while</span> (x[j] &gt; x[l]);<span class="comment">//找到第一个小于等于x[l]</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; j) <span class="keyword">break</span>;<span class="comment">//如果i、j相遇了就说明遍历完了，此时就不用swap(i,j)了</span></span><br><span class="line">        t = x[i]; x[i] = x[j]; x[j] = t;<span class="comment">//swap(i,j)</span></span><br><span class="line">    &#125;</span><br><span class="line">    t = x[l]; x[l] = x[j]; x[j] = t;</span><br><span class="line">    qsort(x, l, j - <span class="number">1</span>);</span><br><span class="line">    qsort(x, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>每次随机选取一个元素做枢轴，方法就是swap(l, randint(l, u));<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bigrand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> RAND_MAX * rand() + rand();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">randint</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> l + bigrand() % (r - l + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qsort</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> i, j, t;</span><br><span class="line">    i = randint(l, r);</span><br><span class="line">    t = x[i]; x[i] = x[l]; x[l] = t;<span class="comment">//先随机找一个数与x[l]交换</span></span><br><span class="line">    i = l; j = r + <span class="number">1</span>; </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>快排的很多时间都浪费在了对小数组的元素移动上，我们可以规定当l与u的差在一定范围内时，采用插入排序并返回。或者直接返回，最后再对整个数组做一次插入排序<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qsort</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r - l &lt; cutoff) <span class="keyword">return</span>;<span class="comment">//cutoff一般可取30到50</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;<span class="comment">//此时数组并不是有序的 而是某些小片段整体小于它右边小片段这样的形式</span></span><br><span class="line">insertSort(x, n);<span class="comment">//调用一次插入排序对基本有序的数组进行排序</span></span><br></pre></td></tr></table></figure></p>
<p>完整的一份代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;cstdio&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;cstdlib&gt; </span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;ctime&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> cutoff 4</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> n)</span> </span>&#123;<span class="comment">//这里为了看到效果我把cutoff设为4</span></span><br><span class="line">    <span class="keyword">int</span> i, j, t;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (j = i; j &gt; <span class="number">0</span> &amp;&amp; x[j] &lt; x[j - <span class="number">1</span>]; j--) &#123;</span><br><span class="line">            t = x[j]; x[j] = x[j - <span class="number">1</span>]; x[j - <span class="number">1</span>] = t;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bigrand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> RAND_MAX * rand() + rand();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">randint</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> l + bigrand() % (r - l + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qsort</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r - l &lt; cutoff) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> i, j, t;</span><br><span class="line">    i = randint(l, r);</span><br><span class="line">    t = x[i]; x[i] = x[l]; x[l] = t;</span><br><span class="line">    i = l; j = r + <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">while</span> (i &lt;= r &amp;&amp; x[i] &lt; x[l]);</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125; <span class="keyword">while</span> (x[j] &gt; x[l]);</span><br><span class="line">        <span class="keyword">if</span> (i &gt; j) <span class="keyword">break</span>;</span><br><span class="line">        t = x[i]; x[i] = x[j]; x[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">    t = x[l]; x[l] = x[j]; x[j] = t;</span><br><span class="line">    qsort(x, l, j - <span class="number">1</span>);</span><br><span class="line">    qsort(x, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    srand((<span class="keyword">unsigned</span>)time(NULL));<span class="comment">//种子生成器，否则rand()一直不变</span></span><br><span class="line">    <span class="keyword">int</span> x[] = &#123;<span class="number">0</span>, -<span class="number">5</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">16</span>&#125;;</span><br><span class="line">    qsort(x, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, x[i]);<span class="comment">//可以看出调用完qsort数组并不是有序的</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    insertSort(x, <span class="number">9</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, x[i]);<span class="comment">//最终数组有序</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果：</span></span><br><span class="line"><span class="comment">//-5 0 2 7 3 3 8 9 16</span></span><br><span class="line"><span class="comment">//-5 0 2 3 3 7 8 9 16</span></span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/编程珠玑/">编程珠玑</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-chapter6-10" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/03/08/chapter6-10/" class="article-date">
  	<time datetime="2015-03-08T13:06:53.000Z" itemprop="datePublished">Mar 8</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/08/chapter6-10/">chapter6-10-估算，最大子向量和，最大子矩阵和，变进制表示</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>72法则</p>
</blockquote>
<p>假如以年利率r%投资一笔钱y年，那么当r * y = 72时，那么这笔钱差不多要翻倍。</p>
<p>6%增长率，12年后翻倍<br>8%增长率，9年后翻倍</p>
<p>当r在5%和10%之间，72法则的误差率小于1%</p>
<blockquote>
<p>给出一个n维向量，找出它的一个子向量x[i…j]，令其中元素的和最大</p>
</blockquote>
<p>比较经典的问题了，直接给最优$O(n)$的算法吧<br>在九度上找了个题写了下，这题要求输出最大和，还有左右下标，存在多个时候，输出起点下标最小那个<br><a href="http://ac.jobdu.com/problem.php?pid=1372" target="_blank" rel="external">http://ac.jobdu.com/problem.php?pid=1372</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;cstdio&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, i, ans, t, n, l, r, nl;<span class="comment">//不用保存整个数组，在线处理即可</span></span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) &amp;&amp; n) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);<span class="comment">//先读取数组第一个数</span></span><br><span class="line">        ans = t = x;<span class="comment">//ans最大值，t当前向量和</span></span><br><span class="line">        l = nl = r = <span class="number">0</span>;<span class="comment">//l，r分别为最终左右下标，nl为当前最大和向量左下标，i为当前右坐标</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">            <span class="keyword">if</span> (t &gt;= <span class="number">0</span>) <span class="comment">//如果当前值非负，就不切换左起点，注意等号，因为要输出左起点最小那个</span></span><br><span class="line">                t += x;</span><br><span class="line">            <span class="keyword">else</span> &#123;<span class="comment">//否则，就必须切换左起点</span></span><br><span class="line">                t = x;</span><br><span class="line">                nl = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (t &gt; ans) &#123;<span class="comment">//如果比最大值大，那么将信息保存</span></span><br><span class="line">                l = nl;</span><br><span class="line">                r = i;</span><br><span class="line">                ans = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>, ans, l, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>最大子矩阵和：一个m * n的矩阵，找出一个子矩阵，使其和最大</p>
</blockquote>
<p>这道题从最大子段和演变而来，首先暴力的思路是遍历所有的子矩阵，这样的子矩阵个数为$\frac{m<em>(m+1)}{2}</em>\frac{n*(n+1)}{2}$，也就是说复杂度为$O(m^2n^2)$，我们需要一种更好的方法。</p>
<p>思路：</p>
<ul>
<li>考虑m = 1的情况，这时问题退化为最大子段和；</li>
<li>m = 2，我们可以对第一行和第二行分别求最大子段和，然后把两行相加为一行，求该行的最大子段和，其中最大的那个就是答案；</li>
<li>m = 3，我们可以对1、2、3行求…，然后对1 + 2， 2 + 3， 1 + 3求…，最后对1 + 2 + 3求最大子段和。</li>
<li>…</li>
<li>发现规律了没，我们只要对$\frac{m*(m+1)}{2}$个n维向量求最大子段和即可。</li>
</ul>
<p>问题转化为：遍历$O(m^2)$个n维向量，分别求最大子段和$O(n)$，总复杂度为$O(m^2n)$<br>其中计算第i行到第j行的对应列元素和的复杂度为$O(n)$，而不是$O(mn)$，比如m = 3，按照1、1 + 2、1 + 2 + 3、2、2 + 3、3这样的顺序，在求1 + 2 + 3时，只要利用1 + 2的结果，就可以在$O(n)$内完成，而不用从1开始重新加起。</p>
<p>POJ这道题是n * n的矩阵，复杂度$O(n^3)$<br><a href="http://poj.org/problem?id=1050" target="_blank" rel="external">http://poj.org/problem?id=1050</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;cstdio&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> N 105</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, i, j, k, ans, tmp;</span><br><span class="line">    <span class="keyword">int</span> x[N][N], s[N];<span class="comment">//s就是那个加和之后的n维向量</span></span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)<span class="comment">//读取矩阵</span></span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x[i][j]);</span><br><span class="line">        ans = x[<span class="number">0</span>][<span class="number">0</span>];<span class="comment">//先把最大值置为x[0][0]</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;<span class="comment">//如果是m行，则i，j的上限为m</span></span><br><span class="line">            <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">                s[k] = <span class="number">0</span>;<span class="comment">//把n维向量置为0，准备加第i行到第j行的向量</span></span><br><span class="line">            <span class="keyword">for</span> (j = i; j &lt; n; j++) &#123;<span class="comment">//如果是m行，这里改为m</span></span><br><span class="line">                <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; n; k++) &#123;<span class="comment">//k是按列相加</span></span><br><span class="line">                    s[k] += x[j][k];</span><br><span class="line">                &#125;<span class="comment">//可以看到求和顺序为0、0 + 1、0 + 2... 0 + (m - 1)、1、1 + 2、...、(m - 2)、(m - 2) + (m - 1)、(m - 1)</span></span><br><span class="line">                tmp = s[<span class="number">0</span>];<span class="comment">//之后求最大子段和</span></span><br><span class="line">                <span class="keyword">for</span> (k = <span class="number">1</span>; k &lt; n; k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (tmp &lt; <span class="number">0</span>) tmp = s[k];</span><br><span class="line">                    <span class="keyword">else</span> tmp += s[k];</span><br><span class="line">                    <span class="keyword">if</span> (tmp &gt; ans) ans = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>空间压缩，变进制表示法</p>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/编程珠玑/">编程珠玑</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-chapter345" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/03/07/chapter345/" class="article-date">
  	<time datetime="2015-03-07T13:06:53.000Z" itemprop="datePublished">Mar 7</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/07/chapter345/">chapter345-3x+1，黑白球，日期函数，程序计时</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>Q1：x为一个正整数，若x是偶数，则x = x / 2；若x为奇数（&gt;1的奇数），则x = 3x + 1；则最终x为1</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (x != <span class="number">1</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (even(x))</span><br><span class="line">		x = x / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		x = <span class="number">3</span> * x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个程序会终止，证明？</p>
<blockquote>
<p>Q2：一个罐子里有黑白豆，每次取两个，若为同色，就扔掉并再放一个黑球，若异色，就都扔掉再放一个白的。证明该过程会终止，并求最终球的颜色。</p>
</blockquote>
<ul>
<li>黑黑 -2黑 +1黑</li>
<li>白白 -2白 +1黑</li>
<li>黑白 白黑 -黑白 + 1白</li>
</ul>
<p>每次都是扔两个，放一个，所以最终肯定会剩一个球终止。<br>白球每次不是-0个，就是-2个，也就是说白球数的奇偶性保持不变，只有在最后剩黑白的情况下，才会剩白的，也就是说：<br>如果原来白球是奇数个，那剩的就是白的，否则剩的就是黑的</p>
<blockquote>
<p>Q3：给定两个日期，求他们之间的天数；给定一个日期，求星期几；</p>
</blockquote>
<p>。</p>
<blockquote>
<p>Q4：程序计时</p>
</blockquote>
<p>用到<time.h>中的函数</time.h></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;cstdio&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;ctime&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> N 1e5</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    clock_t start, end;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    start = clock();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    	<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; N; j++)</span><br><span class="line">    		;</span><br><span class="line">    end = clock();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lf\n"</span>, (<span class="keyword">double</span>)(end - start) / CLOCKS_PER_SEC);</span><br><span class="line">    start = clock();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    	<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; N; j &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">    		;</span><br><span class="line">    end = clock();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lf\n"</span>, (<span class="keyword">double</span>)(end - start) / CLOCKS_PER_SEC);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果：</span></span><br><span class="line"><span class="comment">//24.493000</span></span><br><span class="line"><span class="comment">//0.003000</span></span><br><span class="line"><span class="comment">//可以看出当n=100000时，O(n^2)和O(nlogn)在性能上的巨大差别</span></span><br></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/编程珠玑/">编程珠玑</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-chapter2" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/03/06/chapter2/" class="article-date">
  	<time datetime="2015-03-06T13:06:53.000Z" itemprop="datePublished">Mar 6</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/06/chapter2/">chapter2-翻转向量，变位词，第K大的元素</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>Q1：将一个n元一维向量向左旋转i个位置，也就是循环左移。例如：n=8，i=3时，abcdefgh翻转为defghabc。 </p>
</blockquote>
<p>思路：利用 $BA = (A^TB^T)^T$ 进行翻转即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;cstdio&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;cstring&gt;</span></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = l, m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> t;</span><br><span class="line">    <span class="keyword">for</span> (i = l; i &lt;= m; i++) &#123;</span><br><span class="line">        t = s[i]; s[i] = s[r - i + l]; s[r - i + l] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%s"</span>, s)) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;i);</span><br><span class="line">        n = <span class="built_in">strlen</span>(s);</span><br><span class="line">        reverse(<span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">        reverse(i, n - <span class="number">1</span>);</span><br><span class="line">        reverse(<span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么转置一个m * n的矩阵呢？<br>也可以先按行互换，然后再按列互换，也是一种思路。</p>
<blockquote>
<p>Q2：变位词。有一个词典，其中“pots”、“stop”、“tops”互为变位词。给定一个词找出这个词在词典中的所有变位词。</p>
</blockquote>
<p>思路：先将词典中的每个单词排序，这样变位词都有一样的表示形式，比如上面三个词都可以表示为“opst”，然后将整个词典排序，新来一个词时，先求其标准形式，然后在词典中二分查找即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;cstdio&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;cstring&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;algorithm&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">struct</span> word <span class="comment">//old放原词汇，str为排序后的标准形式</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> old[<span class="number">100</span>], str[<span class="number">100</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;word&gt; dic;<span class="comment">//用vector做一个字典</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(word a, word b)</span> </span>&#123; <span class="comment">//按str标准形式排序</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(a.str, b.str) &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, len, i;<span class="comment">//n:词典中的单词个数</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    word w;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, w.old);</span><br><span class="line">        <span class="built_in">strcpy</span>(w.str, w.old);<span class="comment">//str = old</span></span><br><span class="line">        len = <span class="built_in">strlen</span>(w.str); </span><br><span class="line">        sort(w.str, w.str + len);<span class="comment">// 排序str</span></span><br><span class="line">        dic.push_back(w);<span class="comment">//加入词典</span></span><br><span class="line">    &#125;</span><br><span class="line">    sort(dic.begin(), dic.end(), cmp);<span class="comment">//对整个词典排序</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;word&gt;::iterator l, r, k;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%s"</span>, w.old)) &#123;</span><br><span class="line">        len = <span class="built_in">strlen</span>(w.old);</span><br><span class="line">        <span class="built_in">strcpy</span>(w.str, w.old);</span><br><span class="line">        sort(w.str, w.str + len);<span class="comment">//找到其标准形式</span></span><br><span class="line">        l = lower_bound(dic.begin(), dic.end(), w, cmp);</span><br><span class="line">        r = upper_bound(dic.begin(), dic.end(), w, cmp);</span><br><span class="line">        <span class="keyword">for</span> (k = l; k != r; k++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, (*k).old);<span class="comment">//输出词典中的变位词</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意其中的两个函数，lower_bound(Iterator first, last, key, cmp) 和 upper_bound(Iterator first, last, key, cmp) 这俩都是二分查找的函数</p>
<p>lower_bound返回大于等于key的第一个元素的位置<br>upper_bound返回大于key的第一个元素的位置</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;cstdio&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;cstring&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;algorithm&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">20</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    l = lower_bound(a, a + <span class="number">5</span>, <span class="number">20</span>) - a;</span><br><span class="line">    r = upper_bound(a, a + <span class="number">5</span>, <span class="number">20</span>) - a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, l, r);</span><br><span class="line">    l = lower_bound(a, a + <span class="number">5</span>, <span class="number">10</span>) - a;</span><br><span class="line">    r = upper_bound(a, a + <span class="number">5</span>, <span class="number">10</span>) - a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, l, r);</span><br><span class="line">    l = lower_bound(a, a + <span class="number">5</span>, <span class="number">50</span>) - a;</span><br><span class="line">    r = upper_bound(a, a + <span class="number">5</span>, <span class="number">50</span>) - a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, l, r);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出为：</span></span><br><span class="line"><span class="comment">//0 2</span></span><br><span class="line"><span class="comment">//0 0</span></span><br><span class="line"><span class="comment">//4 5</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Q3：给定一个n元实数集合，一个实数t，一个整数k，是否存在一个k元子集，其元素之和不超过t？</p>
</blockquote>
<p>这道题第一想法就是找出前k个最小的数，看它们的和是否超过t，这样问题转化为：在n个数中，找出前k个最小的数。<br>解法就是，建一个大小为k的最小堆，然后遍历所有元素，复杂度为$O(nlogk)$</p>
<p>但是仔细想下，对于这个问题，我们只需要找到前k个最小的数即可，而这些数之间的大小关系我们并不需要知道，由此想到了什么？<br>当然是快排的步骤中，枢轴左边的数全都小于枢轴元素，我们可以借鉴这个思想，就把问题转化为：求n个数中的第k小数。<br>leetcode上有一道求第K大数的题，我的C代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    k = numsSize - k + <span class="number">1</span>;<span class="comment">//求第K大，我先把它转化为求第K小。。</span></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = numsSize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> i, j, t, m;</span><br><span class="line">    <span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">        i = l, j = r + <span class="number">1</span>;</span><br><span class="line">        t = nums[l];</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">while</span>(i &lt;= r &amp;&amp; nums[i] &lt; t);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;<span class="keyword">while</span>(nums[j] &gt; t);</span><br><span class="line">            <span class="keyword">if</span>(i &gt; j) <span class="keyword">break</span>;</span><br><span class="line">            m = nums[i]; nums[i] = nums[j]; nums[j] = m;</span><br><span class="line">        &#125;</span><br><span class="line">        m = nums[l]; nums[l] = nums[j]; nums[j] = m;</span><br><span class="line">        <span class="comment">//以上为一次快排的交换步骤</span></span><br><span class="line">        <span class="keyword">if</span>(j == k - <span class="number">1</span>) <span class="keyword">return</span> nums[j];<span class="comment">//如果j==k-1，说明左边有k-1个数，也就是它是第k小的数</span></span><br><span class="line">        <span class="keyword">if</span>(j &gt; k - <span class="number">1</span>) r = j - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> l = j + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的复杂度为 $O(n)$</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/编程珠玑/">编程珠玑</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-chapter1" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/03/05/chapter1/" class="article-date">
  	<time datetime="2015-03-05T13:06:53.000Z" itemprop="datePublished">Mar 5</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/05/chapter1/">bitset</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>条件：内存很少（约1MB），最多有1000万个数，所有数的范围都在0-1000万，没有重复数字</p>
<p>分析：一个int有32位，可以用每一位的0、1来表示一个数是否出现，这样一个int可以存32个数的信息（是否出现），这样可以用1.25MB存1000万个数</p>
<p>关键：使用位运算进行编码和解码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;cstdio&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> BITSPERWORD 32</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MASK 0x1f</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> SHIFT 5</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> N 10000000</span></span><br><span class="line"><span class="keyword">int</span> x[N/BITSPERWORD + <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    x[i&gt;&gt;SHIFT] |= (<span class="number">1</span>&lt;&lt;(i&amp;MASK));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clr</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    x[i&gt;&gt;SHIFT] &amp;= ~(<span class="number">1</span>&lt;&lt;(i&amp;MASK));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x[i&gt;&gt;SHIFT] &amp; (<span class="number">1</span>&lt;&lt;(i&amp;MASK));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        clr(i);</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;i))</span><br><span class="line">        <span class="built_in">set</span>(i);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        <span class="keyword">if</span> (test(i))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解释一下这个程序，它是一个int表示32个数，所以在操作的时候，先 i / 32 找到i在数组x中的存储位置，然后i % 32 找到i在这个int中存在第几位。<br>i &gt;&gt; SHIFT 右移5位，就相当于i / 32 找到在x中的位置<br>i &amp; MASK 与0000 0000 0000 0000 0000 0000 0001 1111做与运算，意思就是只保留最后5位二进制，相当于 i % 32，就跟我们常用i &amp; 1判断是不是奇数一个道理</p>
<p>以i=39为例：<br>首先它应该存在x中第二个位置的int中，下标为1，也就是39 / 32 = 1， 找到了x[1]<br>然后它应该在x[1]的第8位存储，也就是39 % 32 = 7，1左移7位，然后x[1]或等这个1000 0000，就是把这个bit位置为1，其他位不变<br>clr(39)，把该位置为0 找到位置之后取反 则只有该位为0 其他位都为1，将x[1]与等这个11111111..111 0111 1111，则此位置为0，其他位不变<br>test(39)，看该位是否为1 </p>
<p>如果内存严格限制为1MB，可以考虑使用多趟的外部排序，之后多路归并。<br>多路归并这里用到了败者树，因为如果K趟归并，需要比较(k - 1)次才能找到最小值，而这里使用败者树则logk就可以，复杂度上与堆相同。<br>但是败者树只有叶子结点存的信息，中间结点存的都是索引（取得是第几个外部文件的值），而堆中间结点也存的信息，无法直接知道是取得哪个外部文件中的值。败者树的结点为2k-1，堆为k。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/bitset/">bitset</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/编程珠玑/">编程珠玑</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 TIAN Xing
    	</div>
      	<div class="footer-right">
      		Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>